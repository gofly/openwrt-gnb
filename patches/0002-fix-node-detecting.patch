From f0bbfdc66441dd70163eaf4d5a6d12adc104a8a1 Mon Sep 17 00:00:00 2001
From: zhenglixin <lixin.zhenglx@gmail.com>
Date: Tue, 7 Oct 2025 21:12:03 +0800
Subject: [PATCH 02/14] fix node detecting

---
 src/gnb_address.c             | 27 ++++++++++++++++++
 src/gnb_address.h             |  3 ++
 src/gnb_index_worker.c        | 45 +++++++++++++++++++++++------
 src/gnb_secure_index_worker.c | 53 ++++++++++++++++++++++++++++-------
 4 files changed, 110 insertions(+), 18 deletions(-)

diff --git a/src/gnb_address.c b/src/gnb_address.c
index 4370280..15e986e 100644
--- a/src/gnb_address.c
+++ b/src/gnb_address.c
@@ -653,3 +653,30 @@ int gnb_determine_subnet4(struct in_addr addr4_a, struct in_addr addr4_b, struct
     return 0;
 
 }
+
+int gnb_address_list_has_ipv4(gnb_address_list_t *address_list) {
+    if (!address_list) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < address_list->num; i++) {
+        if (address_list->array[i].type == AF_INET) {
+            return 1; // Found an IPv4 address
+        }
+    }
+    return 0; // No IPv4 address found
+}
+
+
+int gnb_address_list_has_ipv6(gnb_address_list_t *address_list) {
+    if (!address_list) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < address_list->num; i++) {
+        if (address_list->array[i].type == AF_INET6) {
+            return 1; // Found an IPv6 address
+        }
+    }
+    return 0; // No IPv6 address found
+}
diff --git a/src/gnb_address.h b/src/gnb_address.h
index f0a9b24..d3245ba 100644
--- a/src/gnb_address.h
+++ b/src/gnb_address.h
@@ -40,6 +40,9 @@ void gnb_address_list_release(gnb_address_list_t *address_list);
 //返回 -1 没有找到,  >0 为 address 在 list 中的索引编号
 int gnb_address_list_find(gnb_address_list_t *address_list, gnb_address_t *address);
 
+int gnb_address_list_has_ipv4(gnb_address_list_t *address_list);
+int gnb_address_list_has_ipv6(gnb_address_list_t *address_list);
+
 //把 address 放进列表中一个空的项里
 void gnb_address_list_update(gnb_address_list_t *address_list, gnb_address_t *address);
 
diff --git a/src/gnb_index_worker.c b/src/gnb_index_worker.c
index 83865b0..71da5b0 100644
--- a/src/gnb_index_worker.c
+++ b/src/gnb_index_worker.c
@@ -103,14 +103,14 @@ static void send_post_addr_frame(gnb_worker_t *gnb_index_worker){
 }
 
 
-static void send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *node){
+static int send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *node){
 
     index_worker_ctx_t *index_worker_ctx = gnb_index_worker->ctx;
 
     gnb_core_t *gnb_core = index_worker_ctx->gnb_core;
 
     if ( 0 == gnb_core->index_address_ring.address_list->num ) {
-        return;
+        return -1;
     }
 
     index_worker_ctx->index_frame_payload->sub_type = PAYLOAD_SUB_TYPE_REQUEST_ADDR;
@@ -149,10 +149,10 @@ static void send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *
         gnb_send_address_list_through_all_sockets(gnb_core, gnb_core->index_address_ring.address_list, index_worker_ctx->index_frame_payload,1);
     }
 
-    node->last_request_addr_sec = index_worker_ctx->now_time_sec;
-
     GNB_DEBUG5(gnb_core->log, GNB_LOG_ID_INDEX_WORKER, "SEND REQUEST ADDR %llu ==>%llu lkey[%s] rkey[%s]\n", gnb_core->local_node->uuid64, node->uuid64, GNB_HEX1_BYTE128(gnb_core->local_node->key512), GNB_HEX2_BYTE128(node->key512));
  
+    return 0;
+
 }
 
 
@@ -488,7 +488,36 @@ static void sync_index_node(gnb_worker_t *gnb_index_worker){
         }
 
 
-        if ( (GNB_NODE_STATUS_IPV6_PONG | GNB_NODE_STATUS_IPV4_PONG) & node->udp_addr_status ) {
+        // 只有当所有期望的协议栈都建立P2P连接后才跳过
+        if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV4) && (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV6) ) {
+            // 双栈模式：需要v4和v6都PONG成功
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) && (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) {
+                continue;
+            }
+
+            gnb_address_list_t *static_list = (gnb_address_list_t *)&node->static_address_block;
+            gnb_address_list_t *push_list = (gnb_address_list_t *)&node->push_address_block;
+            gnb_address_list_t *dynamic_list = (gnb_address_list_t *)&node->dynamic_address_block;
+            gnb_address_list_t *resolv_list = (gnb_address_list_t *)&node->resolv_address_block;
+
+            // 如果v4已连接，但v6未连接，检查对端是否真的有v6地址。如果没有，就停止探测。
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) && !(node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) {
+                if ( !gnb_address_list_has_ipv6(static_list) && !gnb_address_list_has_ipv6(push_list) && !gnb_address_list_has_ipv6(dynamic_list) && !gnb_address_list_has_ipv6(resolv_list) ) {
+                    continue; // 对端没有任何已知的IPv6地址，停止探测
+                }
+            }
+
+            // 如果v6已连接，但v4未连接，检查对端是否真的有v4地址。如果没有，就停止探测。
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) && !(node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) ) {
+                if ( !gnb_address_list_has_ipv4(static_list) && !gnb_address_list_has_ipv4(push_list) && !gnb_address_list_has_ipv4(dynamic_list) && !gnb_address_list_has_ipv4(resolv_list) ) {
+                    continue; // 对端没有任何已知的IPv4地址，停止探测
+                }
+            }
+        } else if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV4) && (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) ) {
+            // IPv4-only模式
+            continue;
+        } else if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV6) && (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) {
+            // IPv6-only模式
             continue;
         }
 
@@ -501,9 +530,9 @@ static void sync_index_node(gnb_worker_t *gnb_index_worker){
             detect_node_addr(gnb_index_worker, node);
         }
 
-        send_request_addr_frame(gnb_index_worker,node);
-
-        node->last_request_addr_sec = index_worker_ctx->now_time_sec;
+        if ( 0 == send_request_addr_frame(gnb_index_worker,node) ) {
+            node->last_request_addr_sec = index_worker_ctx->now_time_sec;
+        }
 
     }
 
diff --git a/src/gnb_secure_index_worker.c b/src/gnb_secure_index_worker.c
index c5774db..88b3b56 100644
--- a/src/gnb_secure_index_worker.c
+++ b/src/gnb_secure_index_worker.c
@@ -120,7 +120,7 @@ static void send_post_addr_frame(gnb_worker_t *gnb_index_worker){
 }
 
 /*crypto and sign*/
-static void send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *node){
+static int send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *node){
 
     index_worker_ctx_t *index_worker_ctx = gnb_index_worker->ctx;
     gnb_address_t *address;
@@ -129,7 +129,7 @@ static void send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *
     int i;
 
     if ( 0 == gnb_core->index_address_ring.address_list->num ) {
-        return;
+        return -1;
     }
 
     index_worker_ctx->index_frame_payload->sub_type = PAYLOAD_SUB_TYPE_REQUEST_ADDR;
@@ -183,10 +183,10 @@ static void send_request_addr_frame(gnb_worker_t *gnb_index_worker, gnb_node_t *
 
     }
 
-    node->last_request_addr_sec = index_worker_ctx->now_time_sec;
-
     GNB_DEBUG5(gnb_core->log, GNB_LOG_ID_INDEX_WORKER, "SEND REQUEST ADDR %llu ==>%u lkey[%s] rkey[%s]\n", gnb_core->local_node->uuid64, node->uuid64, GNB_HEX1_BYTE128(gnb_core->local_node->key512), GNB_HEX2_BYTE128(node->key512));
  
+    return 0;
+
 }
 
 /*crypto and sign*/
@@ -568,8 +568,7 @@ static void sync_index_node(gnb_worker_t *gnb_index_worker){
             continue;
         }
 
-
-        if ( (GNB_NODE_STATUS_IPV6_PONG | GNB_NODE_STATUS_IPV4_PONG) & node->udp_addr_status ) {
+        if ( node->detect_count >= GNB_NODE_MAX_DETECT_TIMES ) {
             continue;
         }
 
@@ -578,13 +577,47 @@ static void sync_index_node(gnb_worker_t *gnb_index_worker){
             continue;
         }
 
-        if ( node->detect_count < GNB_NODE_MAX_DETECT_TIMES ) {
-            detect_node_addr(gnb_index_worker, node);
+        // 只有当所有期望的协议栈都建立P2P连接后才跳过
+        if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV4) && (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV6) ) {
+            // 双栈模式：需要v4和v6都PONG成功
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) && (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) { // v4和v6都已连接
+                continue;
+            }
+ 
+            // 如果v6已连接，但v4未连接，检查对端是否真的有v4地址。如果没有，就停止探测。
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) && !(node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) ) {
+                gnb_address_list_t *static_list = (gnb_address_list_t *)&node->static_address_block;
+                gnb_address_list_t *push_list = (gnb_address_list_t *)&node->push_address_block;
+                gnb_address_list_t *dynamic_list = (gnb_address_list_t *)&node->dynamic_address_block;
+                gnb_address_list_t *resolv_list = (gnb_address_list_t *)&node->resolv_address_block;
+                if ( !gnb_address_list_has_ipv4(static_list) && !gnb_address_list_has_ipv4(push_list) && !gnb_address_list_has_ipv4(dynamic_list) && !gnb_address_list_has_ipv4(resolv_list) ) {
+                    continue; // 对端没有任何已知的IPv4地址，停止探测
+                }
+            }
+ 
+            // 如果v4已连接，但v6未连接，检查对端是否真的有v6地址。如果没有，就停止探测。
+            if ( (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) && !(node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) {
+                gnb_address_list_t *static_list = (gnb_address_list_t *)&node->static_address_block;
+                gnb_address_list_t *push_list = (gnb_address_list_t *)&node->push_address_block;
+                gnb_address_list_t *dynamic_list = (gnb_address_list_t *)&node->dynamic_address_block;
+                gnb_address_list_t *resolv_list = (gnb_address_list_t *)&node->resolv_address_block;
+                if ( !gnb_address_list_has_ipv6(static_list) && !gnb_address_list_has_ipv6(push_list) && !gnb_address_list_has_ipv6(dynamic_list) && !gnb_address_list_has_ipv6(resolv_list) ) {
+                    continue; // 对端没有任何已知的IPv6地址，停止探测
+                }
+            }
+        } else if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV4) && (node->udp_addr_status & GNB_NODE_STATUS_IPV4_PONG) ) {
+            // IPv4-only模式
+            continue;
+        } else if ( (gnb_core->conf->udp_socket_type & GNB_ADDR_TYPE_IPV6) && (node->udp_addr_status & GNB_NODE_STATUS_IPV6_PONG) ) {
+            // IPv6-only模式
+            continue;
         }
 
-        send_request_addr_frame(gnb_index_worker,node);
+        detect_node_addr(gnb_index_worker, node);
 
-        node->last_request_addr_sec = index_worker_ctx->now_time_sec;
+        if ( 0 == send_request_addr_frame(gnb_index_worker,node) ) {
+            node->last_request_addr_sec = index_worker_ctx->now_time_sec;
+        }
 
     }
 
-- 
2.37.1 (Apple Git-137.1)

